{"name":"用python扩展GDB","tagline":"gdb python pretty-printer","body":"# python命令行\r\n使用python可以对gdb进行扩展，如果想使用这个特性，需要gdb具有`--with-python`配置项。查看当前gdb配置可以用`show configuration`命令\r\n\r\n```\r\n(gdb) show configuration\r\nThis GDB was configured as follows:\r\n   configure --host=x86_64-apple-darwin13.1.0 --target=x86_64-apple-darwin13.1.0\r\n             --with-auto-load-dir=:${prefix}/share/auto-load\r\n             --with-auto-load-safe-path=:${prefix}/share/auto-load\r\n             --with-expat\r\n             --with-gdb-datadir=/usr/local/Cellar/gdb/7.7.1/share/gdb (relocatable)\r\n             --with-jit-reader-dir=/usr/local/Cellar/gdb/7.7.1/lib/gdb (relocatable)\r\n             --without-libunwind-ia64\r\n             --without-lzma\r\n             --with-python=/System/Library/Frameworks/Python.framework/Versions/2.7\r\n             --with-separate-debug-dir=/usr/local/Cellar/gdb/7.7.1/lib/debug (relocatable)\r\n             --with-zlib\r\n             --without-babeltrace\r\n```\r\n\r\n供gdb调用的py脚本需要放在`data-directory/python`目录下`data-directory`目录是gdb启动时读取的数据文件目录。查看当前的数据文件目录：\r\n```\r\n(gdb) show data-directory\r\nGDB's data directory is \"/usr/local/Cellar/gdb/7.7.1/share/gdb\".\r\n```\r\n\r\nls一下这个目录，可以发现有以下几个目录：\r\n```\r\n(gdb) shell ls /usr/local/Cellar/gdb/7.7.1/share/gdb\r\npython\t\tsyscalls\tsystem-gdbinit\r\n```\r\n\r\n`data-directory/python`是gdb里python解释器默认的脚本搜索路径。\r\ngdb启动的时候会从`data-directory/python/gdb/command`加载自定义命令 \r\n从`data- directory/python/gdb/function`加载convenience functions.\r\n\r\n所谓convenience functions.是指在gdb里面通过`$函数名`调用的函数。\r\n\r\n```\r\n(gdb) call $_streq(\"a\", \"1\")\r\n$2 = 0\r\n(gdb) call $_streq(\"a\", \"a\")\r\n$3 = 1\r\n```\r\n`_streq`是系统定义的，还可以用python脚本自定义convenience functions.\r\n`python-interactive [command]`或者`pi [command]`会启动一个python解释器\r\n`python [command]`或者`py [command]`执行一段python代码\r\n`source [script-name]`运行一个python脚本，脚本必须以.py作为扩展名\r\n`python execfile (\"script-name\")`也可以运行一个python脚本，但它是基于`execfile`的。\r\n\r\n\r\n# 用python写一个gdb命令\r\n\r\ngdb为了支持python，提供了一个gdb模块，在python代码中随时可以`python help(gdb)`来查看gdb模块的帮助，如果想了解某个具体的类(比如FrameDecorator)还可以`python help(gdb.FrameDecorator)` help 命令是学习python gdb模块特别有用的工具。\r\n\r\n本节用python来实现一个查看堆栈信息的程序。在gdb手册里，gdb有以下几个API:\r\n\r\n\tgdb.PYTHONDIR \r\n\t\tgdb中与python模块相关的文件（脚本）都放在这个目录下\r\n\tgdb.execute(command[, from tty [, to_string]])\r\n\t\t执行一个gdb命令,from_tty 表示来自命令行还是脚本。to_string如果为true那么输出就由execute函数返回，否则会打印在gdb的标准输出流上\r\n\tgdb.breakpoints()\r\n\tgdb.parameter(parameter)\r\n\tgdb.history(number)\t\t\r\n\tgdb.parse_and_eval (expression) \r\n\t\t#expression是一条c++语句，执行这条语句，并返回结果。结果是gdb.Value类型的.这个接口在实现一个自定义命令的时候比较有用，因为如果参数是一个表达式的话，就可以用这个接口来计算表达式的值。这个接口也是唯一一种把convenience变量转换为gdb.Value的方法。\r\n\tgdb.find_pc_line (pc)\r\n\tgdb.post_event \r\n\tgdb.write(string [, stream])\r\n\tgdb.flush()\r\n\tgdb.target_charset()\r\n\tgdb.target_wide_charset ()\r\n\tgdb.solib_name (address)\r\n\tgdb.decode_line [expression]\r\n\tgdb.prompt_hook (current prompt)\r\n\r\n写一个打印hello world的命令\r\n\r\n```python\r\nimport gdb\r\n\r\nclass HelloWorld(gdb.Command):\r\n    \"\"\"Greet the whole world.\"\"\"\r\n    def __init__ (self):\r\n        super(HelloWorld, self).__init__(\"hello-world\", gdb.COMMAND_USER)\r\n        \r\n    def invoke (self, args, from_tty):\r\n        argv = gdb.string_to_argv(args)\r\n        if len (argv) != 0:\r\n            raise gdb.GdbError (\"hello-world takes no arguments\")\r\n        print \"Hello, World!\"\r\n\r\nHelloWorld()\r\n```\r\n\r\n写一个打印某个地址区间汇编指令的命令\r\n```python\r\nimport gdb\r\n\r\nclass BackTracePrinter(gdb.Command):\r\n    \"print backtrace \"\r\n    def __init__(self):\r\n        super(BackTracePrinter, self).__init__(\"pretty-backtrace\", gdb.COMMAND_USER)\r\n\r\n    def invoke (self, args, from_tty):\r\n        argv = gdb.string_to_argv(args)\r\n        newestFrame = gdb.newest_frame()\r\n        print \"the newest frame is : \" + newestFrame.name()\r\n\r\n        architecture = newestFrame.architecture()\r\n        print \"this architecture is : \" + architecture.name()\r\n\r\n        for inc in architecture.disassemble(int(argv[0], 16), int(argv[1], 16)):\r\n            print inc['asm']\r\n\r\n\r\nBackTracePrinter()\r\n```\r\n\r\n# Pretty Printing\r\n\r\n用python扩展gdb的命令意义有限，毕竟gdb已经提供了足够的命令用于查看程序的方方面面。它存在的最大意义是pretty printing。不但可以显示STL，boost等标准库容器变量，还可以为自定义的类实现一个pretty printer。当然，在工程实践中我们会定义非常多的类，似乎没有必要为每一个类实现一个pretty printer，但是如果为几个核心的类实现出print printer的话，就可以方便定位，还可以作为新人学习了解模块的有效工具。\r\n\r\n`info pretty-printer`可以查看当前有哪些pretty printers\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  [1]: https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop\r\n  [2]: http://adrai.github.io/flowchart.js/\r\n  [3]: http://bramp.github.io/js-sequence-diagrams/\r\n  [4]: https://dev.yinxiang.com/doc/articles/enml.php","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}